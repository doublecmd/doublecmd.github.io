<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
  <title>Lua Scripting</title>
  <link rel="STYLESHEET" type="text/css" href="doublecmd.css"/>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
</head>

<body>
  <a name="topofpage"></a>
  <div class="CHAPTER">
  <h1>Lua Scripting - Standard Libraries</h1>

  <p>Double Commander can execute Lua scripts via <a href="cmds.html#cm_ExecuteScript">cm_ExecuteScript</a> command. Also it is possible to write content plugins (.wdx) using Lua script.

  <h2>1. Double Commander Functions</h2>

<p>
This library contains Double Commander specific functions.
It provides all its functions inside the table <code>DC</code>.

<p>
<hr><h3>DC.ExecuteCommand(Command, Param1, Param2,...,ParamX)</h3>


<p>
Execute internal Double Commander command <var>Command</var> with parameters <var>Param1</var>..<var>ParamX</var>.
<p>
<h4>Example:</h4>
<pre>
  -- Script command line parameters
  local params = {...}
  print(#params)     -- parameters count
  print(params[1])   -- first parameter
  print(params[2])   -- second parameter

  -- Execute Double Commander command
  DC.ExecuteCommand("cm_ChangeDir", params[1])
</pre>

  <h2>2. System Functions</h2>

<p>
This library contains various system functions.
It provides all its functions inside the table <code>SysUtils</code>.

<p>
<hr><h3>SysUtils.Sleep(Milliseconds)</h3>
<p><var>Sleep</var> suspends the execution of the script for the specified number of milliseconds (<var>Milliseconds</var>).
After the specified period has expired, script execution resumes.
<p>
<hr><h3>SysUtils.FileExists(FileName)</h3>

<p>
Check whether a particular file exists in the filesystem. <var>FileExists</var> returns <var>true</var> if a file with name <var>FileName</var> exists on the disk, <var>false</var> otherwise.

<p>
<hr><h3>SysUtils.DirectoryExists(Directory)</h3>

<p><var>DirectoryExists</var> checks whether <var>Directory</var> exists in the filesystem and is actually a directory.
If this is the case, the function returns <var>true</var>, otherwise <var>false</var> is returned. </p>

<p>
<hr><h3>SysUtils.FileGetAttr(FileName)</h3>

<p><var>FileGetAttr</var> returns the attribute settings of file <var>FileName</var>. The attribute is a <var>OR</var>-ed combination of the following constants: </p>
<dl>
<dt>faReadOnly = 0x00000001</dt>
<dd>The file is read-only.</dd>
<dt>faHidden = 0x00000002</dt>
<dd>The file is hidden. (On unix, this means that the filename starts with a dot) </dd>
<dt>faSysFile = 0x00000004</dt>
<dd>The file is a system file (On unix, this means that the file is a character, block or FIFO file). </dd>
<dt>faVolumeId = 0x00000008</dt>
<dd>Volume Label. Only for DOS/Windows on a plain FAT (not VFAT or Fat32) filesystem.</dd>
<dt>faDirectory = 0x00000010</dt>
<dd>File is a directory.</dd>
<dt>faArchive = 0x00000020</dt>
<dd>file should be archived. Not possible on Unix</dd>
</dl>
<h3>Errors</h3>
<p>In case of error, -1 is returned. </p>
<p>
<h4>Example:</h4>
<pre>
    local k = SysUtils.FileGetAttr(FileName)
    if (k < 0) then
      -- File/folder does not exists
    elseif (math.floor(k / 16) % 2 ~= 0) then
      -- This is a directory
    else
      -- This is a file
    end
</pre>
<hr>
<h3>Handle,FindData = SysUtils.FindFirst(Path)</h3>
<p><var>FindFirst</var> looks for files that match the name (possibly with wildcards) in <var>Path</var>.
If the function succeeds, the return value <var>Handle</var> is a search handle used in a subsequent call to <var>FindNext</var>
or <var>FindClose</var>,
it then fills up the <var>FindData</var> table with data gathered about the file, otherwise <var>nil</var> is returned.</p>
<h3>Result,FindData = SysUtils.FindNext(Handle)</h3>
<p><var>FindNext</var> finds a next occurrence of a search sequence initiated by <var>FindFirst</var>.
<p><var>Handle</var> - The search handle returned by a previous call to the <var>FindFirst</var> function.</p>
<p>If the function succeeds, the return value <var>Result</var> is non-<var>nil</var> and the <var>FindData</var> table contains information about
the next file or directory found.
<br/><br/>
<b>Remark:   </b>
The last <var>FindNext</var> call must <em>always</em> be followed by a <var>FindClose</var> call with the same <var>Handle</var>.
Failure to do so will result in memory loss.
<h3>SysUtils.FindClose(Handle)</h3>
<p>
<var>FindClose</var> ends a series of <var>FindFirst</var>/<var>FindNext</var> calls, and frees any memory used by these calls.
It is <em>absolutely</em> necessary to do this call, or huge memory losses may occur.

<h4>Example:</h4>
<pre>
local Result = nil
local Handle,FindData = SysUtils.FindFirst("/tmp/*")

if Handle ~= nil then
  repeat

    print(FindData.Name)
    print(FindData.Time)
    print(FindData.Attr)
    print(FindData.Size)

    print("---------------")

    Result,FindData = SysUtils.FindNext(Handle)

  until Result == nil

  SysUtils.FindClose(Handle)
end
</pre>
<hr/>
	<p class="NAVBACK"><a href="#topofpage">Top</a></p>
<p><br></p>
	<div class="SECT1">
	  <p class="NAVBACK"><a href="index.html">Home</a></p>
	</div>
<p><br></p>

</body>

</html>
